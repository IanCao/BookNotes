## 简单动态字符串
Redis对于一些无须修改的字符串用C语言传统的字符串来进行存储
而对于可以被修改的字符串则使用SDS(`simple dynamic string`)简单动态字符串进行存储

### SDS的数据结构
```c
struct sdshdr {
    // 记录buf数组中已使用的 字节 的数量
    // 等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
    
    // SDS遵循C字符串以空字符结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性中，并且会为空字符分配额外的1字节的空间
}
```

#### 简单动态字符串（`SDS`）相对于 C语言传统字符串的 优势
##### 1. 常数复杂度获取字符串长度
因为C字符并不记录自身的长度信息，所以每当需要获取C字符串的长度的时候，都需要进行遍历整个字符串。
##### 2. 杜绝缓冲区溢出 
因为C字符串不记录当前字符串可用长度，所以当需要增长C字符串的时候，就需要提前进行扩容操作，否则则可能出现缓冲区溢出。
![dbe3722d2921155601f9fb297af89c69.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENResource/p148)

而对于SDS来说，其保存了free空间，在增长字符串的时候，Redis会先检查SDS的空间是否能够满足要求，否则则会自动将SDS的空间扩容至所需大小
##### 3. 减少修改字符串时带来的内存重分配次数
对于C字符串来说，每次增长或者缩短一个C字符串，都需要对这个C字符串的数组进行一次内存重分配的操作：
 - 如果是增长字符串，则需要进行内存重分配来扩容，如果没有扩容，则会产生缓冲区溢出
 - 如果是缩短字符串，则需要内存重分配来释放额外空间，如果没有释放，则会产生内存泄露

对于SDS来说，使用了**空间预分配**和**惰性空间释放**两种策略来降低内存重分配的次数
######  a. 空间预分配（用于字符串增长的操作）
空间预分配是当SDS字符串要增长的时候，程序不仅会为SDS分配修改所需要的空间，还会为SDS分配额外的未使用的空间.
  - 当对SDS修改之后，SDS的长度(也就是len的值)小于1MB的时候，程序会分配和len属性相同大小的未使用空间。比如，SDS修改之后是13字节，那么程序也会分配13字节的未使用空间，buf数组的实际长度就会是27（包含1字节用于保存尾部的空字符），len为26，free为13.
  - 当对SDS修改之后，SDS的长度大于等于1MB，那么程序会额外分配1MB的未使用空间，

**通过空间预分配策略，SDS将连续增长N的字符串所需要的内存重分配次数从必定N次降低为最多N次**
######  b. 惰性空间释放（用于字符串缩短的操作）
当SDS字符串要缩短时，程序并不会立即使用内存重分配来回收缩短后所出来的字节， 而是使用free属性将这些字节的数量保存起来。

##### 4. 二进制安全
因为C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则会被程序误判。这些限制使得C字符串只能存储文本数据，不能存储图片，音频等二进制数据。

而SDS中是使用len属性的值判断字符串是否结束，而非C字符串使用空字符来判断结束。

##### 5. 兼容部分C字符串函数
SDS也遵循C字符串以空字符结尾的惯例，这是为了让那些保存文本数据的SDS可以重用一部分C字符串的函数。

![ccf31db080a3a961bf2de8f250a5450c.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENResource/p149)

## 链表
##### 链表的数据结构
```c
每个链表节点的数据结构，多个listNode通过prev和next指针组成双端链表
typedef struct listNode {
   // 前置节点
   struct listNode *prev;
   // 后置节点
   struct listNode *next;
   // 节点的值
   void *value;
}listNode;

整个链表的数据结构
typedef struct list {
  // 表头节点
  listNode *head;
  // 表尾节点
  listNode *tail;
  // 链表所包含的节点数量
  unsigned long len;
  // 节点值复制函数：用于复制链表节点所保存的值
  void *(*dup)(void *ptr);
  // 节点值释放函数：用于释放链表节点所保存的值
  void (*free)(void *ptr)
  // 节点值对比函数：用于对比链表节点所保存的值和另一个输入值是否相等
  int (*match)(void *ptr,void *key);
  
}
```

Reids链表的特性：
1. 双端
2. 无环
3. 带表头指针和表尾指针
4. 带链表长度计数器
5. 多态：链表节点使用 `void*` 指针来保存节点值，所以链表可以用于保存各种不同类型的值

## 字典
![adc29d046ae86e17965d1121f6a27e65.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENResource/p150)

dict 为字典的结构
dict中的ht属性是包含两个项的数组，数组中的每个项都是一个dict哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用。
dict中的`rehashidx`是用来记录当前rehash的进度，如果当前没有在进行rehash，那么它的值为-1

dictht则为字典所使用的hash表，table为哈希表的数组，size为哈希表大小，sizemask的值总等于size-1，这是用于计算新元素的索引值。used字段为改哈希表已有节点的数量。

**问题：sizemask既然总等于size-1 为什么还要单独存在这个值？**


##### 解决键冲突
使用链地址法来解决键冲突
每次新节点都添加到链表的表头位置，排在其他已有节点的前面。

##### rehash
1. 为字典的ht[1]哈希表分配空间，这个哈希表的空间大小计算规则如下：
    - 如果是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的 2的n次方
    - 如果是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的 2的n次方
2. 将ht[0]中的元素 rehash到ht[1]中
3. 释放ht[0]，并将ht[1]设为ht[0],并将ht[1]新创建一个空白哈希表，为下一次rehash做准备。

##### rehash的时机
1. 服务器目前没有在执行`BGSAVE`命令或者`BGREWRITEAOF`命令，并且负载因子大于等于1，扩展操作
2. 服务器目前正在执行`BGSAVE`命令或者`BGREWRITEAOF`命令，并且负载因子大于等于5，扩展操作
3. 当负载因子小于0.1的时候，程序自动开始进行收缩操作

> 负载因子 = 哈希表已保存节点数量 / 哈希表大小

#### 为什么服务器会影响rehash的触发负载因子？
因为服务器在执行`BGSAVE`命令或者`BGREWRITEAOF`命令，Redis需要创建当前服务器进程的紫禁城，而大多数操作系统都采用写时复制(copy-on-write)技术来优化子进程的使用效率，而rehash会增大内存读写，并且会多占用内存空间。

##### 渐进式rehash
对于哈希表的扩容活收缩并不是一次性完成的，而是分多次，渐进式完成的。
具体步骤：
1. 为`ht[1]`分配空间，字典同时拥有两个哈希表
2. 更新字典的`rehashidx`为0，代表开始rehash
3. 在rehash期间，每次对字典执行添加，删除，查找或者更新操作时，程序除了执行指定的操作以外，还会顺便等`ht[0]`哈希表在`rehashidx`索引上的所有值rehash至ht[1],并将`rehashidx`的值加一。
4. 随着字典操作的不断执行，终究会rehash完。


##### 渐进式rehash执行期间的哈希表操作
渐进式rehash期间，字典的 删除/查找/更新等操作会在两个哈希表上进行。
即上述操作都会现在ht[0]表中进行查找，如果没找到，再去另外一个表找。

对于新增操作，只会在ht[1]中操作。保证h1[0]只进不出



## 跳跃表
![2011f9252e2643f47ea54ee7baffcc4f.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENResource/p158)
##### 属性描述：
 1. header:指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1)
 2. tail:指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1)
 3. level:记录目前跳跃表内,层数最大的那个节点的层数(表头节点的层数不计算在内)，通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数。
 4. length:记录跳跃表的长度,也即是,跳跃表目前包含节点的数量(表头节点不计算在内)，通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度
 
##### 总结
1. 跳跃表基于单链表加索引的方式实现
2. 跳跃表以空间换时间的方式提升了查找速度
3. Redis有序集合在节点元素较大或者元素数量较多时使用跳跃表实现
4. Redis每个跳跃表节点的层高都是1至32之间的随机数
5. 在同一个跳跃表中,多个节点可以包含相同的分值,但每个节点的成员对象必须是唯一的跳跃表中的节点按照分值大小进行排序,当分值相同时,节点按照成员对象的大小进行排序。

## 整数集合
当一个集合中只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合键的底层实现。

```c
typedef struct intset {
   // 编码方式
   uint32_t encoding;
   // 集合包含的元素数量
   uint32_t length;
   // 保存元素的数组
   int8_t contents[]; // 此数组真正的类型取决于encoding属性的值
}intset;
```
整数集合是Redis用来保存整数值的集合抽象数据结构，它可以保存类型为`int16_t`,`int32_t`或者`int64_t`的整数值，并且保证集合中不会出现重复元素。

#### 升级
每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有元素的类型都要长时，整数集合会先进行升级，然后才能将新元素添加到整数集合里面。

例如：目前有一个int16的数组，每个元素占用16位空间。
![e2587bf744d65454e75bcc244ccdb805.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENResource/p159)
当要新增一个int32的数字 65536的时候，就需要进行升级操作
首先需要根据元素的数量和类型计算出需要再分配多少内存空间。
![f3a1d325c6a6a98e215c2a9d5a1464f0.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENResource/p160)
![1cb5fcc170a953b2236c8b90bcf2defd.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENResource/p161)
![4d45438379cad7656698152c46b6b220.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENResource/p162)
![569bad4bf7e935de45aaabf89cab16f7.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENResource/p163)
![b2a3d8b90dc2ea922e866074c96b0524.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENResource/p164)



#### 升级的好处
 - 提高整数集合的灵活度
    C语言通常不会将两种不同类型的值放在同一个数据结构，因为整数集合可以自动升级，就不会担心出现类型错误的问题
 - 节约内存
    如果我们一直使用int16类型的值，底层存储就会一直是int16类型的数据
    

###### 整数集合不支持降级

## 压缩列表
压缩列表是列表键和哈希键的底层实现之一。
当一个列表键只包含少量的列表项，并且每个列表项要么就是小整数值，要么就是长度比较端的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

压缩列表是由一系列特殊编码的连续内存块组成的顺序型数据结构；每个节点可以保存一个字节数组或者一个整数值。
![16b2091f05c8d8c13cde059ee2a42427.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENNote/p247?hash=16b2091f05c8d8c13cde059ee2a42427)
 - zlbytes：存储一个无符号整数，固定四个字节长度，用于存储压缩列表所占用的字节，当重新分配内存的时候使用，不需要遍历整个列表来计算内存大小。
 - zltail：存储一个无符号整数，固定四个字节长度，代表指向列表尾部的偏移量，偏移量是指压缩列表的起始位置到指定列表节点的起始位置的距离。
 - zllen：压缩列表包含的节点个数，固定两个字节长度，源码中指出当节点个数大于2^16-2个数的时候，该值将无效，此时需要遍历列表来计算列表节点的个数。
 - entryX：列表节点区域，长度不定，由列表节点紧挨着组成。
 - zlend：一字节长度固定值为255，用于表示列表结束。
 
 #### entry的结构如下
 ![2024e779800331b9e00a67786da3c501.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENNote/p247?hash=2024e779800331b9e00a67786da3c501)
##### previous length
用于存储上一个节点的长度，因此压缩列表可以从尾部向头部遍历，即当前节点位置减去上一个节点的长度即得到上一个节点的起始位置。previous length的长度可能是1个字节或者是5个字节，如果上一个节点的长度小于254，则该节点只需要一个字节就可以表示前一个节点的长度了，如果前一个节点的长度大于等于254，则previous length的第一个字节为254，后面用四个字节表示当前节点前一个节点的长度。

##### encoding
节点的`encoding`属性记录了节点的`content`属性所保存数据的类型以及长度
 - 一字节，两字节或者五字节，值的最高位为00，01或者10的是字节数组编码：这种编码表示节点的content属性保存着字节数组，数组的长度由编码除去最高两位之后的其他位记录；
 - 一字节长，值的最高位以11开头的是整数编码：整数值的类型和长度由编码除去最高两位之后的其他位记录；
 ![d6567e106922ee337efa44403caa3b22.png](evernotecid://C67FD36D-5E52-4E6E-8DE0-B74A556D41DA/appyinxiangcom/24205207/ENResource/p167)
 
 ##### content
 节点的content属性负责保存节点的值，节点值可以是一个字节数组或者整数，值的类型和长度由节点的encoding属性决定。
 
 #### 连锁更新
 因为每个节点的`previous length`会存储前一个节点的长度，但是这个属性的长度会根据前一个节点的长度而变化，即如果前一个节点的长度小于254，则使用一个字节来存储；如果大于等于254，则会使用5个字节来存储。
 
 假如一个压缩列表所有的元素的长度都是253字节，然后我们将一个长度大于254的元素放在列表的表头位置，那么第二个元素的`previous length`将会使用5字节来存储，加之自身的长度，就超过了254，则又会影响下一个节点，程序就需要对压缩列表不断地进行空间重分配操作，直到结束。同理，删节点也会有相同的情况。
 
 虽然压缩列表会有连锁更新的情况，但是真正造成性能问题的概率是非常低的。
  - 首先，压缩列表里要恰好有多个连续的，长度介于250-253字节的节点，连锁更新才有可能触发。
  - 即使触发了连锁更新，但是只要被更新的节点数量不多，影响也是可控的。
 
 #### 压缩列表的优势？
 1. 因为数组要求每个元素的大小相同，如果我们要存储不同长度的字符串，那么就需要用最大长度的字符串大小作为元素的大小，但是对于那些小于最大长度的字符串来说，便会浪费部分存储空间。
 2. 数组的优势占用一片连续的空间可以很好的利用CPU缓存访问数据。如果我们想要保留这种优势，又想节省存储空间我们可以对数组进行压缩。