## AOF 持久化
`AOF(Append Only File)`：通过保存`Redis`服务器所执行的写命令来记录数据库状态的

### AOF 持久化的实现
 1. 命令追加(`append`)
    服务器在执行完一个写命令之后，会将此命令追加到服务器状态的`aof_buf`缓冲区的末尾
 2. 文件写入 & 文件同步(`sync`)
    Redis的服务器进程就是一个事件循环(`loop`)
```c
 def eventLoop():
    while True:
       ## 处理文件事件，接收命令请求以及发送命令回复
       ## 处理命令请求时可能会有新内容被追加到 `aof_buf` 缓冲区中
       processFileEvents()
       ## 处理时间事件
       processTimeEvents()
       ## 考虑是否要将 `aof_buf`中的内容写入和保存到AOF文件里面
       flushAppendOnlyFile()
```
 `flushAppendOnlyFile`是策略：
    1. always：每次都保存
    2. everysec: 如果上次同步AOF的时间距离现在超过一秒钟，则同步；并且这个同步操作哦是由一个线程专门负责执行的
    3. no：何时同步由操作系统来决定

### AOF 文件的载入和还原
  ![image.png](https://upload-images.jianshu.io/upload_images/12412504-59cd8a7c1698551f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
### AOF 重写
AOF 文件重写并不需要对现有的AOF文件进行任何读取，分析或者写入操作；
这个功能是通过读取服务器当前的数据库状态来实现的

AOF重写具体步骤：
1. `Redis Server`启动，如果`AOF机`制打开那么初始化`AOF`状态，并且如果存在`AOF`文件，读取`AOF`文件。
2. 随着`Redis`不断接受命令，每个写命令都被添加到`AOF`文件，`AOF`文件膨胀到需要`rewrite`时又或者接收到客户端的`bgrewriteaof`命令。
3. `fork`出一个子进程进行`rewrite`，而父进程继续接受命令，现在的写操作命令都会被额外添加到一个`aof_rewrite_buf_blocks`缓冲中。
4. 当子进程`rewrite`结束后，父进程收到子进程退出信号，把`aof_rewrite_buf_blocks`的缓冲添加到`rewrite`后的文件中，然后切换`AOF`的文件`fd`。`rewrite`任务完成，继续第二个步骤。

## 事件
Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：
1. 文件事件(`file event`)：Redis服务器通过套接字与客户端进行连接，而文件事件就是服务器对套接字操作的抽象。
2. 时间事件(`time event`)：Redis服务器中的一些操作需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。

### 文件事件处理器
文件处理器的四个组成部分：
 - 套接字
 - I/O 多路复用程序
 - 文件事件分派器(`dispatcher`)
 - 事件处理器
![image.png](https://upload-images.jianshu.io/upload_images/12412504-2cf6b7791f45e9d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

I/O多路复用程序会将所有的产生的套接字都放在一个队列里面，然后通过这个队列**有序，同步**向文件事件分派器传送套接字；当上一个套接字事件结束后，才会派发下一个套接字
##### 事件类型
套接字的事件类型： `AE_READABLE` 和 `AE_WRITEABLE` 
 - 当套接字变的可读时(`wriite`操作)，套接字产生`AE_READABLE`事件
 - 当套接字变的可写时(`read`操作)，套接字产生`AE_WRITEABLE`事件
 如果一个套接字又可读又可写时，那么先读套接字，后写套接字
 
##### 文件事件的处理器
  - 连接应答处理器：为了对连接服务器的各个客户端进行应答
  - 命令请求处理器：负责处理从套接字中读入客户端发送的命令请求内容
  - 命令回复处理器：负责将服务器执行命令后得到的命令回复通过套接字返回给客户端
  
### 时间事件
Redis的时间事件：
 - 定时事件：让一段程序在指定的时间之后执行一次。
 - 周期性事件：让一段程序每隔指定的时间就执行一次。
 
 服务器将所有的时间事件都放在一个无序的链表里面。
 每当时间事件执行器运行时，它就会遍历整个链表，查找所有已经到达的时间事件，并调用相应的时间事件处理器。
 时间事件的实际处理时间通常还会比设定的到达时间晚一些。
 
 ## 客户端
 每个客户端在与服务器建立连接的时候，服务端会将客户端的信息存储在服务端
 服务器是通过一个链表来将所有与服务器连接的客户端的进行存储的。新加的客户端会被放在链表的末尾。
 
 #### 输入缓冲区
 客户端状态的输入缓冲区用于保存客户端发送的命令请求;
 输入缓冲区的大小会根据输入内容动态地缩小或者扩大，但它的最大大小不能超过1GB，否则服务器会关闭这个客户端
 #### 输出缓冲区
 执行命令所得到的命令回复会被保存在客户端状态的输出缓冲区里面，每个客户端都有两个缓冲区可用，一个缓冲区的大小是固定的，
 另一个缓冲区的大小是可变的。 
  - 固定大小的缓冲区用于保存那些长度比较小的回复。默认大小为16KB。
  - 可变大小的缓冲区用于保存哪些长度比较大的回复。这是通过链表的方式来存储多个字符串对象
  
服务器通过两种模式来限制客户端输出缓冲区的大小：
 - 硬性限制（`hard limit`）：如果输出缓冲区的大小超过了硬性限制所设置的大小，那么服务器立即关闭客户端。
 - 软性限制（`soft limit`）：如果输出缓冲区的大小超过了软性设置的大小，但是还没有超过硬性，那么服务器将会记录下客户端到达软性限制的起始时间；之后服务器会继续监视客户端，
                          如果输出缓冲区的大小一直超过软性限制，并且持续的时间超过服务器设定的时长，那么服务端将关闭客户端。
 #### LUA脚本的伪客户端
 服务器会在初始化时创建负责执行LUA脚本中包含的Redis命令的伪客户端，这个客户端只有在服务器被关闭时才会被关闭。                         
 
 
 