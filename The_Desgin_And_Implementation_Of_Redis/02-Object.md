## 对象
Redis中的每个对象都由一个`redisObject`结构表示，该结构中的保存数据库有关的三个属性
  - `type`：类型
      - 字符串对象 `REDIS_STRING`
      - 列表对象 `REDIS_LIST`
      - 哈希对象 `REDIS_HASH`
      - 集合对象 `REDIS_SET`
      - 有序集合对象 `REDIS_ZSET`
  - `encoding`：编码
     通过`encoding`属性来设置对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，这使得`Redis`可以根据不同的使用场景来为一个对象设置编码，从而优化对象在某一场景下的效率。
    > 比如列表元素较少时，使用压缩列表作为底层实现比较合适；
    > 但是当列表元素越来越多的时候，压缩列表就不合适了，而适合保存大量元素的双端链表就更合适一些。
  - `ptr`：指向底层实现数据结构的指针
  - `refcount`：引用计数，用于内存回收
  - `lru`：记录了此对象最后一次被命令程序访问的时间
  
 
### 字符串对象
字符串对象的编码可以是
 - `int`： 字符串对象保存的是可以通过long类型表示的整数值
 - `raw`： 字符串对象保存的长度大于32字节
 - `embstr`：字符串对象保存的长度小于等于32字节
 
 
 ##### `raw`和`embstr`的区别是什么？
 `raw`编码会调用**两次内存分配**函数来分别创建`redisObject`和`sdshdr`结构
 `embstr`编码则会通过**一次内存分配**来分配一块连续的空间用来保存`redisObject`和`sdshdr`。
 
 对于浮点类型的数据Redis也是作为字符串存储，而对于字符串的数值操作，Redis会先将字符串值转换为浮点数值，然后计算完之后，再保存为字符串对象。
 
 ![](http://qipju6j8k.hn-bkt.clouddn.com/20201031192243.png)

#### 编码的转换
`int`编码的字符串对象和`embstr`编码的字符串对象在条件满足的情况下，会被转换为`raw`编码的字符串对象。
Redis并没有为`embstr`编码的字符串对象编写任何相应的修改程序，即`embstr`编码的字符串对象实际上是只读的。
我们对于`embstr`编码的字符串对象任何修改命令时，程序都会即将对象的编码从`embstr`转换为`raw`，然后执行命令。

### 列表对象
列表对象的编码为：
 - `ziplist`：压缩列表
 - `linkedlist`：双向链表
 
当列表元素同时满足以下两个条件时，列表对象使用`ziplist`；否则使用`linkedlist`
  1. 列表对象保存的所有字符串元素的长度都小于64字节
  2. 列表对象保存的元素数量小于512个
  
### 哈希对象
哈希对象的编码为：
 - `ziplist`
   使用压缩列表实现，当有新的键值对加入到哈希对象中，程序会先将保存了键的压缩列表推入压缩列表表尾，然后再将保存了值的压缩列表退出到压缩列表表尾，因此：
     - 保存了同一键值对的两个节点总是紧挨在一起，保存键节点在前，保存值的节点在后。
     - 先加入的哈希对象在压缩列表表头
 - `hashtable`
   使用字典作为底层实现

当哈希对象可以同时满足两个条件时，哈希对象使用`ziplist`编码：
 1. 哈希对象保存的所有键值对的键值和的字符串长度都小于64字节；
 2. 哈希对象保存的键值对数量小于512个；

不能满足这两个条件的哈希对象需要使用`hashtable`编码。

### 集合对象
集合对象的编码是
  - `intset`：
  - `hashtable`：
      每个键值对的键为集合元素，而值都设置为`NULL`
 
当集合对象可以同时满足以下两个条件时，对象使用`intset`编码：
 1. 集合对象保存的所有元素都是整数值
 2. 集合对象保存的元素数量不超过512个
否则，则使用`hashtable`编码。

### 有序集合对象
有序集合的编码是
 - `ziplist`
    每个集合元素都是用两个相邻的压缩列表节点保存。第一个节点保存元素的成员，而第二个节点保存则是元素的分值(`score`)
 - `skiplist`：
    此编码的有序集合对象使用`zset`结构作为底层，一个`zset`结构同时包含一个字典和跳跃表
    `zset`结构中的跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素（跳表元素的`Object`属性保存了元素的成员，而跳跃表节点的`score`属性则保存了元素的分值）。而对于有序集合范围型的操作，都是基于跳表实现的。
    而其中的`dict字典`则为为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了元素的分值。通过这个字典，可以通过`O(1)`的复杂度查找给定成员的分值。
    两个数据结构是通过指针来共享相同的元素，故不会出现内存浪费。
    
![](http://qipju6j8k.hn-bkt.clouddn.com/20201031204933.png)
    
    
当有序集合对象可以同时满足以下两个条件时，对象使用`ziplist`编码：
1. 有序集合保存的元素数量小于128个
2. 有序集合保存的所有元素成员的长度都小于64字节；
否则，则使用skiplist编码


## 类型检查
![](http://qipju6j8k.hn-bkt.clouddn.com/20201031205438.png)

### 多态命令
对于`LLENT`命令，服务器除了要保证执行命令的是列表键之外，还需要根据键的值对象所使用的编码来选择正确的`LLEN`命令实现：
 - 比如列表对象的编码为`ziplist`，那么说明列表对象的实现为压缩列表，程序将使用`ziplistLen`函数返回列表长度
 - 如果列表对象的编码为`linkedlist`，那么说明列表对象的实现为双端链表，程序将使用`listLength`函数来返回双端链表的长度。
 
 ### 内存回收
 Redis使用的引用计数的方式来进行内存回收。
 
 ### 对象共享
 当需要新建对象的时候，内存中已经存在相同值的对象，则会将此对象的引用数加一，然后进行对象共享。
 目前Redis会在初始化服务器的时候，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值。
 
 ![](http://qipju6j8k.hn-bkt.clouddn.com/20201031210541.png)
 
 ### 对象的空转时长
 `OBJECT IDLETIME`命令可以打印出对象的lru属性
 当服务器打开`maxmemory`选项，并且服务器用于回收的算法为`volatile-lru`或者`all-keys-lru`，那么当服务器占用的内存超过了`maxmemory`选项所设置的上限值是，空转时间较长的那部分键会优先被服务器释放，从而回收内存